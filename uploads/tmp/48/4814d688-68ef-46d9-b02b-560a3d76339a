{"fragment": "#version 400\n\nstruct BSDF { vec3 response; vec3 throughput; };\n#define EDF vec3\nstruct surfaceshader { vec3 color; vec3 transparency; };\nstruct volumeshader { vec3 color; vec3 transparency; };\nstruct displacementshader { vec3 offset; float scale; };\nstruct lightshader { vec3 intensity; vec3 direction; };\n#define material surfaceshader\n\n// Uniform block: PrivateUniforms\nuniform float u_alphaThreshold = 0.001000;\nuniform sampler2D u_shadowMap;\nuniform mat4 u_shadowMatrix = mat4(1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000);\nuniform mat4 u_envMatrix = mat4(-1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000);\nuniform sampler2D u_envRadiance;\nuniform float u_envLightIntensity = 1.000000;\nuniform int u_envRadianceMips = 1;\nuniform int u_envRadianceSamples = 16;\nuniform sampler2D u_envIrradiance;\nuniform bool u_refractionTwoSided = false;\nuniform vec3 u_viewPosition = vec3(0.0);\nuniform int u_numActiveLightSources = 0;\n\n// Uniform block: PublicUniforms\nuniform surfaceshader backsurfaceshader;\nuniform displacementshader displacementshader1;\nuniform int node_texcoord_vector2_5_index = 0;\nuniform float node_multiply_6_in2 = 2.000000;\nuniform sampler2D node_image_color3_0_file;\nuniform int node_image_color3_0_layer = 0;\nuniform vec3 node_image_color3_0_default = vec3(0.000000, 0.000000, 0.000000);\nuniform int node_image_color3_0_uaddressmode = 2;\nuniform int node_image_color3_0_vaddressmode = 2;\nuniform int node_image_color3_0_filtertype = 1;\nuniform int node_image_color3_0_framerange = 0;\nuniform int node_image_color3_0_frameoffset = 0;\nuniform int node_image_color3_0_frameendaction = 0;\nuniform vec2 node_image_color3_0_uv_scale = vec2(1.000000, 1.000000);\nuniform vec2 node_image_color3_0_uv_offset = vec2(0.000000, 0.000000);\nuniform sampler2D node_image_vector3_9_file;\nuniform int node_image_vector3_9_layer = 0;\nuniform vec3 node_image_vector3_9_default = vec3(0.000000, 0.000000, 0.000000);\nuniform int node_image_vector3_9_uaddressmode = 2;\nuniform int node_image_vector3_9_vaddressmode = 2;\nuniform int node_image_vector3_9_filtertype = 1;\nuniform int node_image_vector3_9_framerange = 0;\nuniform int node_image_vector3_9_frameoffset = 0;\nuniform int node_image_vector3_9_frameendaction = 0;\nuniform vec2 node_image_vector3_9_uv_scale = vec2(1.000000, 1.000000);\nuniform vec2 node_image_vector3_9_uv_offset = vec2(0.000000, 0.000000);\nuniform sampler2D node_image_vector3_7_file;\nuniform int node_image_vector3_7_layer = 0;\nuniform vec3 node_image_vector3_7_default = vec3(0.000000, 0.000000, 0.000000);\nuniform int node_image_vector3_7_uaddressmode = 2;\nuniform int node_image_vector3_7_vaddressmode = 2;\nuniform int node_image_vector3_7_filtertype = 1;\nuniform int node_image_vector3_7_framerange = 0;\nuniform int node_image_vector3_7_frameoffset = 0;\nuniform int node_image_vector3_7_frameendaction = 0;\nuniform vec2 node_image_vector3_7_uv_scale = vec2(1.000000, 1.000000);\nuniform vec2 node_image_vector3_7_uv_offset = vec2(0.000000, 0.000000);\nuniform int node_extract_8_index = 1;\nuniform int node_normalmap_space = 0;\nuniform float node_normalmap_scale = 1.000000;\nuniform float node_mix_1_fg = 0.853000;\nuniform float node_mix_1_bg = 0.058000;\nuniform float SR_TH_Wood_Table_base = 0.800000;\nuniform float SR_TH_Wood_Table_diffuse_roughness = 0.000000;\nuniform float SR_TH_Wood_Table_metalness = 0.000000;\nuniform float SR_TH_Wood_Table_specular = 1.000000;\nuniform vec3 SR_TH_Wood_Table_specular_color = vec3(1.000000, 1.000000, 1.000000);\nuniform float SR_TH_Wood_Table_specular_IOR = 1.500000;\nuniform float SR_TH_Wood_Table_specular_anisotropy = 0.000000;\nuniform float SR_TH_Wood_Table_specular_rotation = 0.000000;\nuniform float SR_TH_Wood_Table_transmission = 0.000000;\nuniform vec3 SR_TH_Wood_Table_transmission_color = vec3(1.000000, 1.000000, 1.000000);\nuniform float SR_TH_Wood_Table_transmission_depth = 0.000000;\nuniform vec3 SR_TH_Wood_Table_transmission_scatter = vec3(0.000000, 0.000000, 0.000000);\nuniform float SR_TH_Wood_Table_transmission_scatter_anisotropy = 0.000000;\nuniform float SR_TH_Wood_Table_transmission_dispersion = 0.000000;\nuniform float SR_TH_Wood_Table_transmission_extra_roughness = 0.000000;\nuniform float SR_TH_Wood_Table_subsurface = 0.000000;\nuniform vec3 SR_TH_Wood_Table_subsurface_color = vec3(1.000000, 1.000000, 1.000000);\nuniform vec3 SR_TH_Wood_Table_subsurface_radius = vec3(1.000000, 1.000000, 1.000000);\nuniform float SR_TH_Wood_Table_subsurface_scale = 1.000000;\nuniform float SR_TH_Wood_Table_subsurface_anisotropy = 0.000000;\nuniform float SR_TH_Wood_Table_sheen = 0.000000;\nuniform vec3 SR_TH_Wood_Table_sheen_color = vec3(1.000000, 1.000000, 1.000000);\nuniform float SR_TH_Wood_Table_sheen_roughness = 0.300000;\nuniform float SR_TH_Wood_Table_coat = 0.000000;\nuniform vec3 SR_TH_Wood_Table_coat_color = vec3(1.000000, 1.000000, 1.000000);\nuniform float SR_TH_Wood_Table_coat_roughness = 0.100000;\nuniform float SR_TH_Wood_Table_coat_anisotropy = 0.000000;\nuniform float SR_TH_Wood_Table_coat_rotation = 0.000000;\nuniform float SR_TH_Wood_Table_coat_IOR = 1.500000;\nuniform float SR_TH_Wood_Table_coat_affect_color = 0.000000;\nuniform float SR_TH_Wood_Table_coat_affect_roughness = 0.000000;\nuniform float SR_TH_Wood_Table_thin_film_thickness = 0.000000;\nuniform float SR_TH_Wood_Table_thin_film_IOR = 1.500000;\nuniform float SR_TH_Wood_Table_emission = 0.000000;\nuniform vec3 SR_TH_Wood_Table_emission_color = vec3(1.000000, 1.000000, 1.000000);\nuniform vec3 SR_TH_Wood_Table_opacity = vec3(1.000000, 1.000000, 1.000000);\nuniform bool SR_TH_Wood_Table_thin_walled = false;\n\nin VertexData\n{\n    vec2 texcoord_0;\n    vec3 normalWorld;\n    vec3 tangentWorld;\n    vec3 positionWorld;\n} vd;\n\n// Pixel shader outputs\nout vec4 out1;\n\n#define M_FLOAT_EPS 1e-8\n\n\nfloat mx_square(float x)\n{\n    return x*x;\n}\nvec2 mx_square(vec2 x)\n{\n    return x*x;\n}\nvec3 mx_square(vec3 x)\n{\n    return x*x;\n}\n#define DIRECTIONAL_ALBEDO_METHOD 0\n\n#define MAX_LIGHT_SOURCES 3\n#define M_PI 3.1415926535897932\n#define M_PI_INV (1.0 / M_PI)\n\n\nfloat mx_pow5(float x)\n{\n    return mx_square(mx_square(x)) * x;\n}\nfloat mx_pow6(float x)\n{\n    float x2 = mx_square(x);\n    return mx_square(x2) * x2;\n}\n// Standard Schlick Fresnel\n\nfloat mx_fresnel_schlick(float cosTheta, float F0)\n{\n    float x = clamp(1.0 - cosTheta, 0.0, 1.0);\n    float x5 = mx_pow5(x);\n    return F0 + (1.0 - F0) * x5;\n}\nvec3 mx_fresnel_schlick(float cosTheta, vec3 F0)\n{\n    float x = clamp(1.0 - cosTheta, 0.0, 1.0);\n    float x5 = mx_pow5(x);\n    return F0 + (1.0 - F0) * x5;\n}\n// Generalized Schlick Fresnel\n\nfloat mx_fresnel_schlick(float cosTheta, float F0, float F90)\n{\n    float x = clamp(1.0 - cosTheta, 0.0, 1.0);\n    float x5 = mx_pow5(x);\n    return mix(F0, F90, x5);\n}\nvec3 mx_fresnel_schlick(float cosTheta, vec3 F0, vec3 F90)\n{\n    float x = clamp(1.0 - cosTheta, 0.0, 1.0);\n    float x5 = mx_pow5(x);\n    return mix(F0, F90, x5);\n}\n// Generalized Schlick Fresnel with a variable exponent\n\nfloat mx_fresnel_schlick(float cosTheta, float F0, float F90, float exponent)\n{\n    float x = clamp(1.0 - cosTheta, 0.0, 1.0);\n    return mix(F0, F90, pow(x, exponent));\n}\nvec3 mx_fresnel_schlick(float cosTheta, vec3 F0, vec3 F90, float exponent)\n{\n    float x = clamp(1.0 - cosTheta, 0.0, 1.0);\n    return mix(F0, F90, pow(x, exponent));\n}\n// Enforce that the given normal is forward-facing from the specified view direction.\n\nvec3 mx_forward_facing_normal(vec3 N, vec3 V)\n{\n    return (dot(N, V) < 0.0) ? -N : N;\n}\n// https://www.graphics.rwth-aachen.de/publication/2/jgt.pdf\n\nfloat mx_golden_ratio_sequence(int i)\n{\n    const float GOLDEN_RATIO = 1.6180339887498948;\n    return fract((float(i) + 1.0) * GOLDEN_RATIO);\n}\n// https://people.irisa.fr/Ricardo.Marques/articles/2013/SF_CGF.pdf\n\nvec2 mx_spherical_fibonacci(int i, int numSamples)\n{\n    return vec2((float(i) + 0.5) / float(numSamples), mx_golden_ratio_sequence(i));\n}\n// Generate a uniform-weighted sample on the unit hemisphere.\n\nvec3 mx_uniform_sample_hemisphere(vec2 Xi)\n{\n    float phi = 2.0 * M_PI * Xi.x;\n    float cosTheta = 1.0 - Xi.y;\n    float sinTheta = sqrt(1.0 - mx_square(cosTheta));\n    return vec3(cos(phi) * sinTheta,\n                sin(phi) * sinTheta,\n                cosTheta);\n}\n// Generate a cosine-weighted sample on the unit hemisphere.\n\nvec3 mx_cosine_sample_hemisphere(vec2 Xi)\n{\n    float phi = 2.0 * M_PI * Xi.x;\n    float cosTheta = sqrt(Xi.y);\n    float sinTheta = sqrt(1.0 - Xi.y);\n    return vec3(cos(phi) * sinTheta,\n                sin(phi) * sinTheta,\n                cosTheta);\n}\n// Construct an orthonormal basis from a unit vector.\n// https://graphics.pixar.com/library/OrthonormalB/paper.pdf\n\nmat3 mx_orthonormal_basis(vec3 N)\n{\n    float sign = (N.z < 0.0) ? -1.0 : 1.0;\n    float a = -1.0 / (sign + N.z);\n    float b = N.x * N.y * a;\n    vec3 X = vec3(1.0 + sign * N.x * N.x * a, sign * b, -sign * N.x);\n    vec3 Y = vec3(b, sign + N.y * N.y * a, -N.y);\n    return mat3(X, Y, N);\n}\nconst int FRESNEL_MODEL_DIELECTRIC = 0;\nconst int FRESNEL_MODEL_CONDUCTOR = 1;\nconst int FRESNEL_MODEL_SCHLICK = 2;\n\n// Parameters for Fresnel calculations\nstruct FresnelData\n{\n    // Fresnel model\n    int model;\n    bool airy;\n\n    // Physical Fresnel\n    vec3 ior;\n    vec3 extinction;\n\n    // Generalized Schlick Fresnel\n    vec3 F0;\n    vec3 F82;\n    vec3 F90;\n    float exponent;\n\n    // Thin film\n    float tf_thickness;\n    float tf_ior;\n\n    // Refraction\n    bool refraction;\n};\n\n// https://media.disneyanimation.com/uploads/production/publication_asset/48/asset/s2012_pbs_disney_brdf_notes_v3.pdf\n// Appendix B.2 Equation 13\n\nfloat mx_ggx_NDF(vec3 H, vec2 alpha)\n{\n    vec2 He = H.xy / alpha;\n    float denom = dot(He, He) + mx_square(H.z);\n    return 1.0 / (M_PI * alpha.x * alpha.y * mx_square(denom));\n}\n// https://ggx-research.github.io/publication/2023/06/09/publication-ggx.html\n\nvec3 mx_ggx_importance_sample_VNDF(vec2 Xi, vec3 V, vec2 alpha)\n{\n    // Transform the view direction to the hemisphere configuration.\n    V = normalize(vec3(V.xy * alpha, V.z));\n\n    // Sample a spherical cap in (-V.z, 1].\n    float phi = 2.0 * M_PI * Xi.x;\n    float z = (1.0 - Xi.y) * (1.0 + V.z) - V.z;\n    float sinTheta = sqrt(clamp(1.0 - z * z, 0.0, 1.0));\n    float x = sinTheta * cos(phi);\n    float y = sinTheta * sin(phi);\n    vec3 c = vec3(x, y, z);\n\n    // Compute the microfacet normal.\n    vec3 H = c + V;\n\n    // Transform the microfacet normal back to the ellipsoid configuration.\n    H = normalize(vec3(H.xy * alpha, max(H.z, 0.0)));\n\n    return H;\n}\n// https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n// Equation 34\n\nfloat mx_ggx_smith_G1(float cosTheta, float alpha)\n{\n    float cosTheta2 = mx_square(cosTheta);\n    float tanTheta2 = (1.0 - cosTheta2) / cosTheta2;\n    return 2.0 / (1.0 + sqrt(1.0 + mx_square(alpha) * tanTheta2));\n}\n// Height-correlated Smith masking-shadowing\n// http://jcgt.org/published/0003/02/03/paper.pdf\n// Equations 72 and 99\n\nfloat mx_ggx_smith_G2(float NdotL, float NdotV, float alpha)\n{\n    float alpha2 = mx_square(alpha);\n    float lambdaL = sqrt(alpha2 + (1.0 - alpha2) * mx_square(NdotL));\n    float lambdaV = sqrt(alpha2 + (1.0 - alpha2) * mx_square(NdotV));\n    return 2.0 / (lambdaL / NdotL + lambdaV / NdotV);\n}\n// Rational quadratic fit to Monte Carlo data for GGX directional albedo.\n\nvec3 mx_ggx_dir_albedo_analytic(float NdotV, float alpha, vec3 F0, vec3 F90)\n{\n    float x = NdotV;\n    float y = alpha;\n    float x2 = mx_square(x);\n    float y2 = mx_square(y);\n    vec4 r = vec4(0.1003, 0.9345, 1.0, 1.0) +\n             vec4(-0.6303, -2.323, -1.765, 0.2281) * x +\n             vec4(9.748, 2.229, 8.263, 15.94) * y +\n             vec4(-2.038, -3.748, 11.53, -55.83) * x * y +\n             vec4(29.34, 1.424, 28.96, 13.08) * x2 +\n             vec4(-8.245, -0.7684, -7.507, 41.26) * y2 +\n             vec4(-26.44, 1.436, -36.11, 54.9) * x2 * y +\n             vec4(19.99, 0.2913, 15.86, 300.2) * x * y2 +\n             vec4(-5.448, 0.6286, 33.37, -285.1) * x2 * y2;\n    vec2 AB = clamp(r.xy / r.zw, 0.0, 1.0);\n    return F0 * AB.x + F90 * AB.y;\n}\nvec3 mx_ggx_dir_albedo_table_lookup(float NdotV, float alpha, vec3 F0, vec3 F90)\n{\n#if DIRECTIONAL_ALBEDO_METHOD == 1\n    if (textureSize(u_albedoTable, 0).x > 1)\n    {\n        vec2 AB = texture(u_albedoTable, vec2(NdotV, alpha)).rg;\n        return F0 * AB.x + F90 * AB.y;\n    }\n#endif\n    return vec3(0.0);\n}\n// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n\nvec3 mx_ggx_dir_albedo_monte_carlo(float NdotV, float alpha, vec3 F0, vec3 F90)\n{\n    NdotV = clamp(NdotV, M_FLOAT_EPS, 1.0);\n    vec3 V = vec3(sqrt(1.0 - mx_square(NdotV)), 0, NdotV);\n\n    vec2 AB = vec2(0.0);\n    const int SAMPLE_COUNT = 64;\n    for (int i = 0; i < SAMPLE_COUNT; i++)\n    {\n        vec2 Xi = mx_spherical_fibonacci(i, SAMPLE_COUNT);\n\n        // Compute the half vector and incoming light direction.\n        vec3 H = mx_ggx_importance_sample_VNDF(Xi, V, vec2(alpha));\n        vec3 L = -reflect(V, H);\n        \n        // Compute dot products for this sample.\n        float NdotL = clamp(L.z, M_FLOAT_EPS, 1.0);\n        float VdotH = clamp(dot(V, H), M_FLOAT_EPS, 1.0);\n\n        // Compute the Fresnel term.\n        float Fc = mx_fresnel_schlick(VdotH, 0.0, 1.0);\n\n        // Compute the per-sample geometric term.\n        // https://hal.inria.fr/hal-00996995v2/document, Algorithm 2\n        float G2 = mx_ggx_smith_G2(NdotL, NdotV, alpha);\n        \n        // Add the contribution of this sample.\n        AB += vec2(G2 * (1.0 - Fc), G2 * Fc);\n    }\n\n    // Apply the global component of the geometric term and normalize.\n    AB /= mx_ggx_smith_G1(NdotV, alpha) * float(SAMPLE_COUNT);\n\n    // Return the final directional albedo.\n    return F0 * AB.x + F90 * AB.y;\n}\nvec3 mx_ggx_dir_albedo(float NdotV, float alpha, vec3 F0, vec3 F90)\n{\n#if DIRECTIONAL_ALBEDO_METHOD == 0\n    return mx_ggx_dir_albedo_analytic(NdotV, alpha, F0, F90);\n#elif DIRECTIONAL_ALBEDO_METHOD == 1\n    return mx_ggx_dir_albedo_table_lookup(NdotV, alpha, F0, F90);\n#else\n    return mx_ggx_dir_albedo_monte_carlo(NdotV, alpha, F0, F90);\n#endif\n}\nfloat mx_ggx_dir_albedo(float NdotV, float alpha, float F0, float F90)\n{\n    return mx_ggx_dir_albedo(NdotV, alpha, vec3(F0), vec3(F90)).x;\n}\n// https://blog.selfshadow.com/publications/turquin/ms_comp_final.pdf\n// Equations 14 and 16\n\nvec3 mx_ggx_energy_compensation(float NdotV, float alpha, vec3 Fss)\n{\n    float Ess = mx_ggx_dir_albedo(NdotV, alpha, 1.0, 1.0);\n    return 1.0 + Fss * (1.0 - Ess) / Ess;\n}\nfloat mx_ggx_energy_compensation(float NdotV, float alpha, float Fss)\n{\n    return mx_ggx_energy_compensation(NdotV, alpha, vec3(Fss)).x;\n}\n// Compute the average of an anisotropic alpha pair.\n\nfloat mx_average_alpha(vec2 alpha)\n{\n    return sqrt(alpha.x * alpha.y);\n}\n// Convert a real-valued index of refraction to normal-incidence reflectivity.\n\nfloat mx_ior_to_f0(float ior)\n{\n    return mx_square((ior - 1.0) / (ior + 1.0));\n}\n// Convert normal-incidence reflectivity to real-valued index of refraction.\n\nfloat mx_f0_to_ior(float F0)\n{\n    float sqrtF0 = sqrt(clamp(F0, 0.01, 0.99));\n    return (1.0 + sqrtF0) / (1.0 - sqrtF0);\n}\nvec3 mx_f0_to_ior(vec3 F0)\n{\n    vec3 sqrtF0 = sqrt(clamp(F0, 0.01, 0.99));\n    return (vec3(1.0) + sqrtF0) / (vec3(1.0) - sqrtF0);\n}\n// https://renderwonk.com/publications/wp-generalization-adobe/gen-adobe.pdf\n\nvec3 mx_fresnel_hoffman_schlick(float cosTheta, FresnelData fd)\n{\n    const float COS_THETA_MAX = 1.0 / 7.0;\n    const float COS_THETA_FACTOR = 1.0 / (COS_THETA_MAX * pow(1.0 - COS_THETA_MAX, 6.0));\n\n    float x = clamp(cosTheta, 0.0, 1.0);\n    vec3 a = mix(fd.F0, fd.F90, pow(1.0 - COS_THETA_MAX, fd.exponent)) * (vec3(1.0) - fd.F82) * COS_THETA_FACTOR;\n    return mix(fd.F0, fd.F90, pow(1.0 - x, fd.exponent)) - a * x * mx_pow6(1.0 - x);\n}\n// https://seblagarde.wordpress.com/2013/04/29/memo-on-fresnel-equations/\n\nfloat mx_fresnel_dielectric(float cosTheta, float ior)\n{\n    float c = cosTheta;\n    float g2 = ior*ior + c*c - 1.0;\n    if (g2 < 0.0)\n    {\n        // Total internal reflection\n        return 1.0;\n    }\n\n    float g = sqrt(g2);\n    return 0.5 * mx_square((g - c) / (g + c)) *\n                (1.0 + mx_square(((g + c) * c - 1.0) / ((g - c) * c + 1.0)));\n}\n// https://seblagarde.wordpress.com/2013/04/29/memo-on-fresnel-equations/\n\nvec2 mx_fresnel_dielectric_polarized(float cosTheta, float ior)\n{\n    float cosTheta2 = mx_square(clamp(cosTheta, 0.0, 1.0));\n    float sinTheta2 = 1.0 - cosTheta2;\n\n    float t0 = max(ior * ior - sinTheta2, 0.0);\n    float t1 = t0 + cosTheta2;\n    float t2 = 2.0 * sqrt(t0) * cosTheta;\n    float Rs = (t1 - t2) / (t1 + t2);\n\n    float t3 = cosTheta2 * t0 + sinTheta2 * sinTheta2;\n    float t4 = t2 * sinTheta2;\n    float Rp = Rs * (t3 - t4) / (t3 + t4);\n\n    return vec2(Rp, Rs);\n}\n// https://seblagarde.wordpress.com/2013/04/29/memo-on-fresnel-equations/\n\nvoid mx_fresnel_conductor_polarized(float cosTheta, vec3 n, vec3 k, out vec3 Rp, out vec3 Rs)\n{\n    float cosTheta2 = mx_square(clamp(cosTheta, 0.0, 1.0));\n    float sinTheta2 = 1.0 - cosTheta2;\n    vec3 n2 = n * n;\n    vec3 k2 = k * k;\n\n    vec3 t0 = n2 - k2 - vec3(sinTheta2);\n    vec3 a2plusb2 = sqrt(t0 * t0 + 4.0 * n2 * k2);\n    vec3 t1 = a2plusb2 + vec3(cosTheta2);\n    vec3 a = sqrt(max(0.5 * (a2plusb2 + t0), 0.0));\n    vec3 t2 = 2.0 * a * cosTheta;\n    Rs = (t1 - t2) / (t1 + t2);\n\n    vec3 t3 = cosTheta2 * a2plusb2 + vec3(sinTheta2 * sinTheta2);\n    vec3 t4 = t2 * sinTheta2;\n    Rp = Rs * (t3 - t4) / (t3 + t4);\n}\nvec3 mx_fresnel_conductor(float cosTheta, vec3 n, vec3 k)\n{\n    vec3 Rp, Rs;\n    mx_fresnel_conductor_polarized(cosTheta, n, k, Rp, Rs);\n    return 0.5 * (Rp  + Rs);\n}\n// https://belcour.github.io/blog/research/publication/2017/05/01/brdf-thin-film.html\n\nvoid mx_fresnel_conductor_phase_polarized(float cosTheta, float eta1, vec3 eta2, vec3 kappa2, out vec3 phiP, out vec3 phiS)\n{\n    vec3 k2 = kappa2 / eta2;\n    vec3 sinThetaSqr = vec3(1.0) - cosTheta * cosTheta;\n    vec3 A = eta2*eta2*(vec3(1.0)-k2*k2) - eta1*eta1*sinThetaSqr;\n    vec3 B = sqrt(A*A + mx_square(2.0*eta2*eta2*k2));\n    vec3 U = sqrt((A+B)/2.0);\n    vec3 V = max(vec3(0.0), sqrt((B-A)/2.0));\n\n    phiS = atan(2.0*eta1*V*cosTheta, U*U + V*V - mx_square(eta1*cosTheta));\n    phiP = atan(2.0*eta1*eta2*eta2*cosTheta * (2.0*k2*U - (vec3(1.0)-k2*k2) * V),\n                mx_square(eta2*eta2*(vec3(1.0)+k2*k2)*cosTheta) - eta1*eta1*(U*U+V*V));\n}\n// https://belcour.github.io/blog/research/publication/2017/05/01/brdf-thin-film.html\n\nvec3 mx_eval_sensitivity(float opd, vec3 shift)\n{\n    // Use Gaussian fits, given by 3 parameters: val, pos and var\n    float phase = 2.0*M_PI * opd;\n    vec3 val = vec3(5.4856e-13, 4.4201e-13, 5.2481e-13);\n    vec3 pos = vec3(1.6810e+06, 1.7953e+06, 2.2084e+06);\n    vec3 var = vec3(4.3278e+09, 9.3046e+09, 6.6121e+09);\n    vec3 xyz = val * sqrt(2.0*M_PI * var) * cos(pos * phase + shift) * exp(- var * phase*phase);\n    xyz.x   += 9.7470e-14 * sqrt(2.0*M_PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift[0]) * exp(- 4.5282e+09 * phase*phase);\n    return xyz / 1.0685e-7;\n}\n// A Practical Extension to Microfacet Theory for the Modeling of Varying Iridescence\n// https://belcour.github.io/blog/research/publication/2017/05/01/brdf-thin-film.html\n\nvec3 mx_fresnel_airy(float cosTheta, FresnelData fd)\n{\n    // XYZ to CIE 1931 RGB color space (using neutral E illuminant)\n    const mat3 XYZ_TO_RGB = mat3(2.3706743, -0.5138850, 0.0052982, -0.9000405, 1.4253036, -0.0146949, -0.4706338, 0.0885814, 1.0093968);\n\n    // Assume vacuum on the outside\n    float eta1 = 1.0;\n    float eta2 = max(fd.tf_ior, eta1);\n    vec3 eta3 = (fd.model == FRESNEL_MODEL_SCHLICK) ? mx_f0_to_ior(fd.F0) : fd.ior;\n    vec3 kappa3 = (fd.model == FRESNEL_MODEL_SCHLICK) ? vec3(0.0) : fd.extinction;\n    float cosThetaT = sqrt(1.0 - (1.0 - mx_square(cosTheta)) * mx_square(eta1 / eta2));\n\n    // First interface\n    vec2 R12 = mx_fresnel_dielectric_polarized(cosTheta, eta2 / eta1);\n    if (cosThetaT <= 0.0)\n    {\n        // Total internal reflection\n        R12 = vec2(1.0);\n    }\n    vec2 T121 = vec2(1.0) - R12;\n\n    // Second interface\n    vec3 R23p, R23s;\n    if (fd.model == FRESNEL_MODEL_SCHLICK)\n    {\n        vec3 f = mx_fresnel_hoffman_schlick(cosThetaT, fd);\n        R23p = 0.5 * f;\n        R23s = 0.5 * f;\n    }\n    else\n    {\n        mx_fresnel_conductor_polarized(cosThetaT, eta3 / eta2, kappa3 / eta2, R23p, R23s);\n    }\n\n    // Phase shift\n    float cosB = cos(atan(eta2 / eta1));\n    vec2 phi21 = vec2(cosTheta < cosB ? 0.0 : M_PI, M_PI);\n    vec3 phi23p, phi23s;\n    if (fd.model == FRESNEL_MODEL_SCHLICK)\n    {\n        phi23p = vec3((eta3[0] < eta2) ? M_PI : 0.0,\n                      (eta3[1] < eta2) ? M_PI : 0.0,\n                      (eta3[2] < eta2) ? M_PI : 0.0);\n        phi23s = phi23p;\n    }\n    else\n    {\n        mx_fresnel_conductor_phase_polarized(cosThetaT, eta2, eta3, kappa3, phi23p, phi23s);\n    }\n    vec3 r123p = max(sqrt(R12.x*R23p), 0.0);\n    vec3 r123s = max(sqrt(R12.y*R23s), 0.0);\n\n    // Iridescence term\n    vec3 I = vec3(0.0);\n    vec3 Cm, Sm;\n\n    // Optical path difference\n    float distMeters = fd.tf_thickness * 1.0e-9;\n    float opd = 2.0 * eta2 * cosThetaT * distMeters;\n\n    // Iridescence term using spectral antialiasing for Parallel polarization\n\n    // Reflectance term for m=0 (DC term amplitude)\n    vec3 Rs = (mx_square(T121.x) * R23p) / (vec3(1.0) - R12.x*R23p);\n    I += R12.x + Rs;\n\n    // Reflectance term for m>0 (pairs of diracs)\n    Cm = Rs - T121.x;\n    for (int m=1; m<=2; m++)\n    {\n        Cm *= r123p;\n        Sm  = 2.0 * mx_eval_sensitivity(float(m) * opd, float(m)*(phi23p+vec3(phi21.x)));\n        I  += Cm*Sm;\n    }\n\n    // Iridescence term using spectral antialiasing for Perpendicular polarization\n\n    // Reflectance term for m=0 (DC term amplitude)\n    vec3 Rp = (mx_square(T121.y) * R23s) / (vec3(1.0) - R12.y*R23s);\n    I += R12.y + Rp;\n\n    // Reflectance term for m>0 (pairs of diracs)\n    Cm = Rp - T121.y;\n    for (int m=1; m<=2; m++)\n    {\n        Cm *= r123s;\n        Sm  = 2.0 * mx_eval_sensitivity(float(m) * opd, float(m)*(phi23s+vec3(phi21.y)));\n        I  += Cm*Sm;\n    }\n\n    // Average parallel and perpendicular polarization\n    I *= 0.5;\n\n    // Convert back to RGB reflectance\n    I = clamp(XYZ_TO_RGB * I, 0.0, 1.0);\n\n    return I;\n}\nFresnelData mx_init_fresnel_dielectric(float ior, float tf_thickness, float tf_ior)\n{\n    FresnelData fd;\n    fd.model = FRESNEL_MODEL_DIELECTRIC;\n    fd.airy = tf_thickness > 0.0;\n    fd.ior = vec3(ior);\n    fd.extinction = vec3(0.0);\n    fd.F0 = vec3(0.0);\n    fd.F82 = vec3(0.0);\n    fd.F90 = vec3(0.0);\n    fd.exponent = 0.0;\n    fd.tf_thickness = tf_thickness;\n    fd.tf_ior = tf_ior;\n    fd.refraction = false;\n    return fd;\n}\nFresnelData mx_init_fresnel_conductor(vec3 ior, vec3 extinction, float tf_thickness, float tf_ior)\n{\n    FresnelData fd;\n    fd.model = FRESNEL_MODEL_CONDUCTOR;\n    fd.airy = tf_thickness > 0.0;\n    fd.ior = ior;\n    fd.extinction = extinction;\n    fd.F0 = vec3(0.0);\n    fd.F82 = vec3(0.0);\n    fd.F90 = vec3(0.0);\n    fd.exponent = 0.0;\n    fd.tf_thickness = tf_thickness;\n    fd.tf_ior = tf_ior;\n    fd.refraction = false;\n    return fd;\n}\nFresnelData mx_init_fresnel_schlick(vec3 F0, vec3 F82, vec3 F90, float exponent, float tf_thickness, float tf_ior)\n{\n    FresnelData fd;\n    fd.model = FRESNEL_MODEL_SCHLICK;\n    fd.airy = tf_thickness > 0.0;\n    fd.ior = vec3(0.0);\n    fd.extinction = vec3(0.0);\n    fd.F0 = F0;\n    fd.F82 = F82;\n    fd.F90 = F90;\n    fd.exponent = exponent;\n    fd.tf_thickness = tf_thickness;\n    fd.tf_ior = tf_ior;\n    fd.refraction = false;\n    return fd;\n}\nvec3 mx_compute_fresnel(float cosTheta, FresnelData fd)\n{\n    if (fd.airy)\n    {\n         return mx_fresnel_airy(cosTheta, fd);\n    }\n    else if (fd.model == FRESNEL_MODEL_DIELECTRIC)\n    {\n        return vec3(mx_fresnel_dielectric(cosTheta, fd.ior.x));\n    }\n    else if (fd.model == FRESNEL_MODEL_CONDUCTOR)\n    {\n        return mx_fresnel_conductor(cosTheta, fd.ior, fd.extinction);\n    }\n    else\n    {\n        return mx_fresnel_hoffman_schlick(cosTheta, fd);\n    }\n}\n// Compute the refraction of a ray through a solid sphere.\n\nvec3 mx_refraction_solid_sphere(vec3 R, vec3 N, float ior)\n{\n    R = refract(R, N, 1.0 / ior);\n    vec3 N1 = normalize(R * dot(R, N) - N * 0.5);\n    return refract(R, N1, ior);\n}\nvec2 mx_latlong_projection(vec3 dir)\n{\n    float latitude = -asin(dir.y) * M_PI_INV + 0.5;\n    float longitude = atan(dir.x, -dir.z) * M_PI_INV * 0.5 + 0.5;\n    return vec2(longitude, latitude);\n}\nvec3 mx_latlong_map_lookup(vec3 dir, mat4 transform, float lod, sampler2D envSampler)\n{\n    vec3 envDir = normalize((transform * vec4(dir,0.0)).xyz);\n    vec2 uv = mx_latlong_projection(envDir);\n    return textureLod(envSampler, uv, lod).rgb;\n}\n// Return the mip level with the appropriate coverage for a filtered importance sample.\n// https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch20.html\n// Section 20.4 Equation 13\n\nfloat mx_latlong_compute_lod(vec3 dir, float pdf, float maxMipLevel, int envSamples)\n{\n    const float MIP_LEVEL_OFFSET = 1.5;\n    float effectiveMaxMipLevel = maxMipLevel - MIP_LEVEL_OFFSET;\n    float distortion = sqrt(1.0 - mx_square(dir.y));\n    return max(effectiveMaxMipLevel - 0.5 * log2(float(envSamples) * pdf * distortion), 0.0);\n}\nvec3 mx_environment_radiance(vec3 N, vec3 V, vec3 X, vec2 alpha, int distribution, FresnelData fd)\n{\n    // Generate tangent frame.\n    X = normalize(X - dot(X, N) * N);\n    vec3 Y = cross(N, X);\n    mat3 tangentToWorld = mat3(X, Y, N);\n\n    // Transform the view vector to tangent space.\n    V = vec3(dot(V, X), dot(V, Y), dot(V, N));\n\n    // Compute derived properties.\n    float NdotV = clamp(V.z, M_FLOAT_EPS, 1.0);\n    float avgAlpha = mx_average_alpha(alpha);\n    float G1V = mx_ggx_smith_G1(NdotV, avgAlpha);\n    \n    // Integrate outgoing radiance using filtered importance sampling.\n    // http://cgg.mff.cuni.cz/~jaroslav/papers/2008-egsr-fis/2008-egsr-fis-final-embedded.pdf\n    vec3 radiance = vec3(0.0);\n    int envRadianceSamples = u_envRadianceSamples;\n    for (int i = 0; i < envRadianceSamples; i++)\n    {\n        vec2 Xi = mx_spherical_fibonacci(i, envRadianceSamples);\n\n        // Compute the half vector and incoming light direction.\n        vec3 H = mx_ggx_importance_sample_VNDF(Xi, V, alpha);\n        vec3 L = fd.refraction ? mx_refraction_solid_sphere(-V, H, fd.ior.x) : -reflect(V, H);\n        \n        // Compute dot products for this sample.\n        float NdotL = clamp(L.z, M_FLOAT_EPS, 1.0);\n        float VdotH = clamp(dot(V, H), M_FLOAT_EPS, 1.0);\n\n        // Sample the environment light from the given direction.\n        vec3 Lw = tangentToWorld * L;\n        float pdf = mx_ggx_NDF(H, alpha) * G1V / (4.0 * NdotV);\n        float lod = mx_latlong_compute_lod(Lw, pdf, float(u_envRadianceMips - 1), envRadianceSamples);\n        vec3 sampleColor = mx_latlong_map_lookup(Lw, u_envMatrix, lod, u_envRadiance);\n\n        // Compute the Fresnel term.\n        vec3 F = mx_compute_fresnel(VdotH, fd);\n\n        // Compute the geometric term.\n        float G = mx_ggx_smith_G2(NdotL, NdotV, avgAlpha);\n\n        // Compute the combined FG term, which is inverted for refraction.\n        vec3 FG = fd.refraction ? vec3(1.0) - (F * G) : F * G;\n\n        // Add the radiance contribution of this sample.\n        // From https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n        //   incidentLight = sampleColor * NdotL\n        //   microfacetSpecular = D * F * G / (4 * NdotL * NdotV)\n        //   pdf = D * G1V / (4 * NdotV);\n        //   radiance = incidentLight * microfacetSpecular / pdf\n        radiance += samp